// Generated by CoffeeScript 1.10.0
(function() {
  var APIBlueprintGenerator;

  (function(root) {
    var ref;
    if ((ref = root.bundle) != null ? ref.minApiVersion('0.2.0') : void 0) {
      return root.Mustache = require("./mustache");
    } else {
      return require("mustache.js");
    }
  })(this);

  APIBlueprintGenerator = function() {
    this.response = function(exchange) {
      var body, body_indentation, has_body, has_headers, headers, is_json, key, ref, value;
      if (!exchange) {
        return null;
      }
      headers = [];
      is_json = false;
      ref = exchange.responseHeaders;
      for (key in ref) {
        value = ref[key];
        if (key === 'Content-Type' || key === 'Connection' || key === 'Date' || key === 'Via' || key === 'Server' || key === 'Content-Length') {
          is_json = key === 'Content-Type' && value.search(/(json)/i) > -1;
          continue;
        }
        headers.push({
          key: key,
          value: value
        });
      }
      has_headers = headers.length > 0;
      body = exchange.responseBody;
      has_body = body.length > 0;
      if (has_body) {
        if (is_json) {
          body = JSON.stringify(JSON.parse(body), null, 4);
        }
        body_indentation = '        ';
        if (has_headers) {
          body_indentation += '    ';
        }
        body = body.replace(/^/gm, body_indentation);
      }
      return {
        statusCode: exchange.responseStatusCode,
        contentType: exchange.responseHeaders['Content-Type'],
        "headers?": has_headers,
        headers: headers,
        "body?": has_headers && has_body,
        body: body
      };
    };
    this.request = function(paw_request) {
      var body, body_indentation, description, has_body, has_description, has_headers, headers, is_json, key, ref, value;
      headers = [];
      is_json = false;
      ref = paw_request.headers;
      for (key in ref) {
        value = ref[key];
        if (key === 'Content-Type') {
          is_json = value.search(/(json)/i) > -1;
          continue;
        }
        headers.push({
          key: key,
          value: value
        });
      }
      has_headers = headers.length > 0;
      body = paw_request.body;
      has_body = body.length > 0;
      if (has_body) {
        if (is_json) {
          body = JSON.stringify(JSON.parse(body), null, 4);
        }
        body_indentation = '        ';
        if (has_headers) {
          body_indentation += '    ';
        }
        body = body.replace(/^/gm, body_indentation);
      }
      description = paw_request.description;
      has_description = description && description.length > 0;
      if (has_headers || has_body || paw_request.headers['Content-Type']) {
        return {
          "headers?": has_headers,
          headers: headers,
          contentType: paw_request.headers['Content-Type'],
          "body?": has_headers && has_body,
          body: body,
          "description?": has_description,
          description: description
        };
      }
    };
    this.parameter = function(paw_request) {
      var body, body_parameters, has_body, i, is_json, key, len, param, parameters, url_parameters, value;
      parameters = [];
      body = paw_request.body;
      has_body = body.length > 0;
      url_parameters = paw_request.getUrlParameters();
      for (key in url_parameters) {
        value = url_parameters[key];
        parameters.push({
          name: key,
          example: value,
          type: this.isNumber(value)
        });
      }
      if (has_body) {
        is_json = this.isJSON(paw_request);
        if (is_json) {
          body_parameters = JSON.parse(body);
          for (key in body_parameters) {
            value = body_parameters[key];
            parameters.push({
              name: key,
              example: value,
              type: this.isNumber(value)
            });
          }
        } else {
          body_parameters = body.split("&");
          for (i = 0, len = body_parameters.length; i < len; i++) {
            value = body_parameters[i];
            param = value.split("=");
            parameters.push({
              name: param[0],
              example: param[1],
              type: this.isNumber(param[1])
            });
          }
        }
      }
      return {
        "parameters?": parameters.length > 0,
        parameters: parameters
      };
    };
    this.path = function(url) {
      var path;
      path = url.replace(/^https?:\/\/[^\/]+/i, '');
      if (!path) {
        path = '/';
      }
      return path;
    };
    this.isJSON = function(paw_request) {
      var is_json, key, ref, value;
      ref = paw_request.headers;
      for (key in ref) {
        value = ref[key];
        if (key === 'Content-Type') {
          is_json = value.search(/(json)/i) > -1;
          break;
        }
      }
      return is_json;
    };
    this.isNumber = function(value) {
      var match;
      match = /^[0-9]*$/.test(value);
      if (match && value.length !== 0) {
        return "number";
      } else {
        return "string";
      }
    };
    this.generate = function(context) {
      var paw_request, template, url;
      paw_request = context.getCurrentRequest();
      url = paw_request.url;
      template = readFile("apiblueprint.mustache");
      return Mustache.render(template, {
        method: paw_request.method,
        path: this.path(url),
        request: this.request(paw_request),
        response: this.response(paw_request.getLastExchange()),
        parameter: this.parameter(paw_request)
      });
    };
  };

  APIBlueprintGenerator.identifier = "io.apiary.PawExtensions.APIBlueprintGenerator";

  APIBlueprintGenerator.title = "API Blueprint Generator";

  APIBlueprintGenerator.fileExtension = "md";

  registerCodeGenerator(APIBlueprintGenerator);

}).call(this);
